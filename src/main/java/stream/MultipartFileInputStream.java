package stream;

import model.ByteSignature;
import util.RWUtil;

import java.io.EOFException;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.zip.ZipException;
import java.util.zip.ZipInputStream;

/**
 * This class implements an input stream for reading multipart splitted files generated by MultipartFileInputStream.
 */
public class MultipartFileInputStream extends InputStream {
	private String filePath;
	private Path currentFile;
	private int partRead;
	private int partSize;
	private InputStream inputStream;


	public MultipartFileInputStream(String filePath) throws IOException {
		if(filePath == null || filePath.isEmpty()) {
			throw new IllegalArgumentException("Invalid file path.");
		}
		if(!filePath.endsWith("zip")) {
			throw new IOException("Invalid file type");
		}
		this.filePath = filePath;
		this.partRead = 0;
		this.partSize = getPartSize();
		openNextPart();
	}

	private byte[] buf = new byte[12];
	private int readPartHeader() throws IOException {
		readFully(buf, 0, 12);
		long signature = RWUtil.get64(buf, 0);
		if(signature != ByteSignature.PART.getValue()) {
			throw new IOException("invalid currentFile type");
		}
		int partNumber = (int)RWUtil.get32(buf, 8);
		return partNumber;
	}

	/**
	 * get total number of partition file by reading file.
	 */
	private int getPartSize() throws IOException {
		inputStream = Files.newInputStream(Paths.get(filePath));
		int lastPartNumber = readPartHeader();
		inputStream.close();
		return lastPartNumber + 1;
	}

	/**
	 * open next partition file and read its header.
	 */
	private void openNextPart() throws IOException {
		if(partRead == partSize - 1) {
			currentFile = Paths.get(filePath);
		} else {
			currentFile = Paths.get(filePath.substring(0,filePath.length()-2) + partRead);
		}
		inputStream = Files.newInputStream(currentFile);
		int partFileNum = readPartHeader();
		if(partFileNum != partRead) {
			throw new IOException("Invalid partition number");
		}
	}

	@Override public int read() throws IOException {
		return read(new byte[1]);
	}

	@Override public int read(byte[] b) throws IOException {
		return read(b, 0, b.length);
	}

	/**
	 * Reads from the current partition. if current partition arrived EOF,
	 * Open next partition and read remaining byte from the partition.
	 * If current partition is last partition, just return readLength
	 */
	@Override public int read(byte[] b, int off, int length) throws IOException {
		if(partRead == partSize) return -1;

		int readLength = inputStream.read(b, off, length);
		if(readLength == -1 || readLength != length) {
			if(partRead < partSize) {
				inputStream.close();
				partRead++;
				if(partRead == partSize) {
					return readLength;
				}
				openNextPart();
				if(readLength < 0) readLength = 0;
				int newReadLength = inputStream.read(b, off + readLength, length - readLength);
				if(newReadLength > 0) readLength += newReadLength;
			}

		}
		return readLength;
	}

	private void readFully(byte[] b, int off, int len) throws IOException {
		while (len > 0) {
			int n = inputStream.read(b, off, len);
			if (n == -1) {
				throw new EOFException();
			}
			off += n;
			len -= n;
		}
	}

}
